# TaskApp Cursor Rules

## ðŸŽ¯ Project Overview

TaskApp is a modern task management application built with React 19, Vite 7, Firebase, and TailwindCSS. This is a production-ready application focused on user experience, performance, and maintainability.

## ðŸ› ï¸ Technology Stack

### Core Technologies

- **Frontend**: React 19 + Vite 7
- **Styling**: TailwindCSS v4
- **State Management**: React Context + Hooks
- **Routing**: React Router DOM
- **Animations**: Framer Motion
- **Database**: Firebase Firestore
- **Authentication**: Firebase Auth
- **Hosting**: Firebase Hosting
- **Analytics**: Firebase Analytics
- **Error Tracking**: Sentry

### Development Tools

- **Language**: JavaScript (ES2023)
- **Type Safety**: JSDoc annotations
- **Testing**: Vitest + React Testing Library
- **Linting**: ESLint + Prettier
- **CI/CD**: GitHub Actions
- **Package Manager**: npm

## ðŸ“¦ Package Installation Commands

### Core Dependencies

```bash
# React and Vite
npm install react@19 react-dom@19 vite@7

# Routing
npm install react-router-dom@6

# Styling
npm install tailwindcss@4 postcss autoprefixer

# Animations
npm install framer-motion@11

# Firebase
npm install firebase@10

# Error Tracking
npm install @sentry/react @sentry/vite-plugin

# Utilities
npm install clsx lucide-react
```

### Development Dependencies

```bash
# Testing
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom

# Linting and Formatting
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier

# Build Tools
npm install -D @vitejs/plugin-react vite-plugin-pwa workbox-window

# Type Checking
npm install -D @types/react @types/react-dom
```

## ðŸŽ¨ Coding Style Guidelines

### 1. Functional Programming Approach

- Use functional components with hooks
- Prefer pure functions over class methods
- Use immutable data patterns
- Avoid side effects in render functions

### 2. Component Structure

```javascript
// âœ… Good: Functional component with hooks
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';

const TaskCard = ({ task, onUpdate, onDelete }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editData, setEditData] = useState(task);

  useEffect(() => {
    setEditData(task);
  }, [task]);

  const handleSave = () => {
    onUpdate(editData);
    setIsEditing(false);
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="task-card"
    >
      {/* Component content */}
    </motion.div>
  );
};

export default TaskCard;
```

### 3. File Organization

```
src/
â”œâ”€â”€ components/          # React components
â”‚   â”œâ”€â”€ ui/             # Base UI components
â”‚   â”œâ”€â”€ dashboardV2/    # Dashboard-specific components
â”‚   â””â”€â”€ auth/           # Authentication components
â”œâ”€â”€ pages/              # Route pages
â”œâ”€â”€ contexts/           # React Context providers
â”œâ”€â”€ hooks/              # Custom React hooks
â”œâ”€â”€ services/           # Business logic services
â”œâ”€â”€ lib/                # Utility libraries
â”œâ”€â”€ styles/             # CSS styles
â””â”€â”€ assets/             # Static assets
```

### 4. Naming Conventions

- **Components**: PascalCase (e.g., `TaskCard`, `UserProfile`)
- **Files**: PascalCase for components, camelCase for utilities
- **Variables**: camelCase (e.g., `taskData`, `isLoading`)
- **Constants**: SCREAMING_SNAKE_CASE (e.g., `API_BASE_URL`)
- **CSS Classes**: kebab-case (e.g., `task-card`, `user-profile`)

## ðŸ”§ Best Practices

### 1. React Best Practices

- Use functional components with hooks
- Implement proper error boundaries
- Use React.memo for performance optimization
- Implement proper key props for lists
- Use controlled components for forms
- Lazy load routes and heavy components
- Use useMemo and useCallback appropriately
- Implement virtual scrolling for long lists

### 2. UI/UX Best Practices

- **Accessibility First**: WCAG 2.1 AA compliance mandatory
  - Minimum 4.5:1 contrast ratio for text
  - Keyboard navigation for all interactive elements
  - ARIA labels for icon buttons and complex widgets
  - Screen reader support with semantic HTML
  
- **Performance Targets**:
  - Page load time: < 1 second
  - Time to Interactive: < 1.5 seconds
  - Animation frame rate: 60 FPS
  - Bundle size (initial): < 200 KB gzipped
  
- **Micro-interactions**:
  - Provide immediate feedback for user actions
  - Use optimistic UI updates
  - Implement smooth transitions (200-300ms)
  - Add loading states for async operations
  
- **Error Handling**:
  - Show helpful error messages (no technical jargon)
  - Provide recovery actions
  - Use toast notifications for non-critical errors
  - Implement error boundaries for critical failures
  
- **Empty States**:
  - Use friendly illustrations
  - Provide clear call-to-action
  - Offer helpful tips for getting started
  - Make empty states discoverable

### 3. State Management

- Use useState for local state
- Use useContext for global state
- Use useReducer for complex state logic
- Avoid prop drilling with context
- Keep state as close to where it's used as possible

### 4. Performance Optimization

- Use React.memo for expensive components
- Implement useMemo and useCallback where appropriate
- Lazy load routes and components
- Optimize images and assets
- Use code splitting
- Implement virtual scrolling for lists > 100 items
- Use transform and opacity for animations (GPU-accelerated)
- Debounce expensive operations (search, validation)
- Implement pagination for large datasets
- Optimize Firestore queries with proper indexes

### 5. Error Handling

- Implement error boundaries
- Use try-catch blocks for async operations
- Provide meaningful error messages
- Log errors for debugging
- Handle network errors gracefully
- Show recovery actions (retry, contact support)
- Use appropriate error severity levels
- Implement offline error handling

### 6. Accessibility (WCAG 2.1 AA Compliance)

- Use semantic HTML elements (header, nav, main, aside, footer)
- Implement proper ARIA attributes (aria-label, aria-describedby, aria-live)
- Ensure keyboard navigation (Tab, Enter, Escape, Arrow keys)
- Maintain color contrast ratios (4.5:1 for text, 3:1 for UI components)
- Test with screen readers (VoiceOver, NVDA)
- Add skip links for keyboard users
- Implement focus traps in modals
- Use visible focus indicators (3px outline)
- Provide text alternatives for images
- Ensure form labels are properly associated

## ðŸŽ¨ Styling Guidelines

### 1. TailwindCSS Usage

- Use utility classes for styling
- Create custom components for repeated patterns
- Use CSS custom properties for theming
- Implement responsive design with mobile-first approach
- Use consistent spacing and typography scales

### 2. Component Styling

```javascript
// âœ… Good: TailwindCSS with custom classes
const Button = ({ variant, size, children, ...props }) => {
  const baseClasses = "font-medium rounded-lg transition-colors focus:outline-none focus:ring-2";
  
  const variantClasses = {
    primary: "bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500",
    danger: "bg-red-600 text-white hover:bg-red-700 focus:ring-red-500"
  };
  
  const sizeClasses = {
    sm: "px-3 py-1.5 text-sm",
    md: "px-4 py-2 text-base",
    lg: "px-6 py-3 text-lg"
  };
  
  const classes = cn(baseClasses, variantClasses[variant], sizeClasses[size]);
  
  return (
    <button className={classes} {...props}>
      {children}
    </button>
  );
};
```

### 3. Responsive Design

- Use mobile-first approach
- Implement consistent breakpoints
- Test on multiple screen sizes
- Use flexible layouts
- Optimize for touch interactions

## ðŸ§ª Testing Guidelines

### 1. Test Structure

- Write unit tests for components
- Write integration tests for services
- Write E2E tests for critical user flows
- Maintain 80%+ test coverage
- Use descriptive test names

### 2. Component Testing

```javascript
// âœ… Good: Component test structure
import { render, screen, fireEvent } from '@testing-library/react';
import TaskCard from '../TaskCard';

describe('TaskCard', () => {
  const mockTask = {
    id: '1',
    title: 'Test Task',
    description: 'Test Description',
    completed: false
  };

  it('should render task information', () => {
    render(<TaskCard task={mockTask} />);
    expect(screen.getByText('Test Task')).toBeInTheDocument();
  });

  it('should call onUpdate when task is edited', () => {
    const mockOnUpdate = jest.fn();
    render(<TaskCard task={mockTask} onUpdate={mockOnUpdate} />);
    
    fireEvent.click(screen.getByRole('button', { name: /edit/i }));
    // Test edit functionality
  });
});
```

## ðŸ”’ Security Guidelines

### 1. Input Validation

- Validate all user inputs
- Sanitize data before storing
- Use proper data types
- Implement rate limiting
- Handle malicious input gracefully

### 2. Authentication & Authorization

- Use Firebase Auth for authentication
- Implement proper role-based access
- Validate user permissions
- Secure API endpoints
- Handle session management

### 3. Data Protection

- Encrypt sensitive data
- Use HTTPS for all communications
- Implement proper CORS policies
- Validate file uploads
- Handle user data privacy

## ðŸ“Š Performance Guidelines

### 1. Bundle Optimization

- Use code splitting
- Implement lazy loading
- Optimize images and assets
- Minimize bundle size
- Use CDN for static assets

### 2. Runtime Performance

- Optimize re-renders
- Use proper memoization
- Implement virtual scrolling
- Optimize animations
- Monitor performance metrics

### 3. Caching Strategy

- Implement service worker caching
- Use browser caching
- Cache API responses
- Implement offline functionality
- Optimize cache invalidation

## ðŸš€ Deployment Guidelines

### 1. Build Process

- Use Vite for building
- Implement proper environment variables
- Optimize for production
- Generate source maps
- Validate build output

### 2. Firebase Deployment

- Use Firebase Hosting
- Implement proper redirects
- Configure security headers
- Set up monitoring
- Implement rollback strategy

### 3. CI/CD Pipeline

- Use GitHub Actions
- Implement automated testing
- Run linting and formatting
- Deploy to staging first
- Implement proper versioning

## ðŸ“š Documentation Guidelines

### 1. Code Documentation

- Use JSDoc for functions
- Document component props
- Explain complex logic
- Provide usage examples
- Keep documentation updated

### 2. README Files

- Provide setup instructions
- Document API endpoints
- Include contribution guidelines
- Provide troubleshooting tips
- Keep examples current

### 3. Architecture Documentation

- Document system architecture
- Explain design decisions
- Provide data flow diagrams
- Document security measures
- Keep technical specs updated

## ðŸ”§ Development Workflow

### 1. Git Workflow

- Use feature branches
- Write descriptive commit messages
- Implement pull request reviews
- Use conventional commits
- Maintain clean git history

### 2. Code Review Process

- Review code thoroughly
- Check for security issues
- Verify performance impact
- Ensure accessibility compliance
- Test functionality manually

### 3. Release Process

- Use semantic versioning
- Generate changelog
- Test in staging environment
- Deploy during low-traffic hours
- Monitor post-deployment

## ðŸŽ¯ Quality Standards

### 1. Code Quality

- Maintain clean, readable code
- Follow established patterns
- Implement proper error handling
- Use consistent formatting
- Write maintainable code

### 2. User Experience

- Ensure intuitive interface
- Implement proper loading states
- Provide meaningful feedback
- Handle errors gracefully
- Maintain consistent behavior

### 3. Performance

- Achieve fast load times
- Implement smooth animations
- Optimize for mobile devices
- Ensure responsive design
- Monitor performance metrics

## ðŸš¨ Common Pitfalls to Avoid

### 1. React Anti-patterns

- Don't mutate state directly
- Avoid using index as key
- Don't forget to clean up effects
- Avoid unnecessary re-renders
- Don't ignore accessibility

### 2. Performance Issues

- Avoid large bundle sizes
- Don't overuse animations
- Avoid blocking operations
- Don't ignore mobile performance
- Avoid memory leaks

### 3. Security Vulnerabilities

- Don't trust user input
- Avoid exposing sensitive data
- Don't ignore authentication
- Avoid insecure dependencies
- Don't skip security updates

## ðŸ“– Additional Resources

### 1. Documentation

- [React Documentation](https://react.dev/)
- [Vite Documentation](https://vitejs.dev/)
- [TailwindCSS Documentation](https://tailwindcss.com/docs)
- [Firebase Documentation](https://firebase.google.com/docs)
- [Framer Motion Documentation](https://www.framer.com/motion/)

### 2. Best Practices

- [React Best Practices](https://react.dev/learn)
- [Web Accessibility Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [Performance Best Practices](https://web.dev/performance/)
- [Security Best Practices](https://owasp.org/www-project-top-ten/)

### 3. Tools and Extensions

- React Developer Tools
- Redux DevTools
- Lighthouse
- WebPageTest
- axe DevTools

---

**LÆ°u Ã½**: CÃ¡c quy táº¯c nÃ y Ä‘Æ°á»£c thiáº¿t káº¿ Ä‘á»ƒ Ä‘áº£m báº£o tÃ­nh nháº¥t quÃ¡n, cháº¥t lÆ°á»£ng vÃ  kháº£ nÄƒng báº£o trÃ¬ cá»§a codebase. Táº¥t cáº£ team members cáº§n tuÃ¢n theo cÃ¡c quy táº¯c nÃ y khi phÃ¡t triá»ƒn tÃ­nh nÄƒng má»›i.