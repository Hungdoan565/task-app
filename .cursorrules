# TaskApp Cursor Rules

## 🎯 Project Overview

TaskApp is a modern task management application built with React 19, Vite 7, Firebase, and TailwindCSS. This is a production-ready application focused on user experience, performance, and maintainability.

## 🛠️ Technology Stack

### Core Technologies

- **Frontend**: React 19 + Vite 7
- **Styling**: TailwindCSS v4
- **State Management**: React Context + Hooks
- **Routing**: React Router DOM
- **Animations**: Framer Motion
- **Database**: Firebase Firestore
- **Authentication**: Firebase Auth
- **Hosting**: Firebase Hosting
- **Analytics**: Firebase Analytics
- **Error Tracking**: Sentry

### Development Tools

- **Language**: JavaScript (ES2023)
- **Type Safety**: JSDoc annotations
- **Testing**: Vitest + React Testing Library
- **Linting**: ESLint + Prettier
- **CI/CD**: GitHub Actions
- **Package Manager**: npm

## 📦 Package Installation Commands

### Core Dependencies

```bash
# React and Vite
npm install react@19 react-dom@19 vite@7

# Routing
npm install react-router-dom@6

# Styling
npm install tailwindcss@4 postcss autoprefixer

# Animations
npm install framer-motion@11

# Firebase
npm install firebase@10

# Error Tracking
npm install @sentry/react @sentry/vite-plugin

# Utilities
npm install clsx lucide-react
```

### Development Dependencies

```bash
# Testing
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom

# Linting and Formatting
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier

# Build Tools
npm install -D @vitejs/plugin-react vite-plugin-pwa workbox-window

# Type Checking
npm install -D @types/react @types/react-dom
```

## 🎨 Coding Style Guidelines

### 1. Functional Programming Approach

- Use functional components with hooks
- Prefer pure functions over class methods
- Use immutable data patterns
- Avoid side effects in render functions

### 2. Component Structure

```javascript
// ✅ Good: Functional component with hooks
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';

const TaskCard = ({ task, onUpdate, onDelete }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editData, setEditData] = useState(task);

  useEffect(() => {
    setEditData(task);
  }, [task]);

  const handleSave = () => {
    onUpdate(editData);
    setIsEditing(false);
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="task-card"
    >
      {/* Component content */}
    </motion.div>
  );
};

export default TaskCard;
```

### 3. File Organization

```
src/
├── components/          # React components
│   ├── ui/             # Base UI components
│   ├── dashboardV2/    # Dashboard-specific components
│   └── auth/           # Authentication components
├── pages/              # Route pages
├── contexts/           # React Context providers
├── hooks/              # Custom React hooks
├── services/           # Business logic services
├── lib/                # Utility libraries
├── styles/             # CSS styles
└── assets/             # Static assets
```

### 4. Naming Conventions

- **Components**: PascalCase (e.g., `TaskCard`, `UserProfile`)
- **Files**: PascalCase for components, camelCase for utilities
- **Variables**: camelCase (e.g., `taskData`, `isLoading`)
- **Constants**: SCREAMING_SNAKE_CASE (e.g., `API_BASE_URL`)
- **CSS Classes**: kebab-case (e.g., `task-card`, `user-profile`)

## 🔧 Best Practices

### 1. React Best Practices

- Use functional components with hooks
- Implement proper error boundaries
- Use React.memo for performance optimization
- Implement proper key props for lists
- Use controlled components for forms
- Lazy load routes and heavy components
- Use useMemo and useCallback appropriately
- Implement virtual scrolling for long lists

### 2. UI/UX Best Practices

- **Accessibility First**: WCAG 2.1 AA compliance mandatory
  - Minimum 4.5:1 contrast ratio for text
  - Keyboard navigation for all interactive elements
  - ARIA labels for icon buttons and complex widgets
  - Screen reader support with semantic HTML
  
- **Performance Targets**:
  - Page load time: < 1 second
  - Time to Interactive: < 1.5 seconds
  - Animation frame rate: 60 FPS
  - Bundle size (initial): < 200 KB gzipped
  
- **Micro-interactions**:
  - Provide immediate feedback for user actions
  - Use optimistic UI updates
  - Implement smooth transitions (200-300ms)
  - Add loading states for async operations
  
- **Error Handling**:
  - Show helpful error messages (no technical jargon)
  - Provide recovery actions
  - Use toast notifications for non-critical errors
  - Implement error boundaries for critical failures
  
- **Empty States**:
  - Use friendly illustrations
  - Provide clear call-to-action
  - Offer helpful tips for getting started
  - Make empty states discoverable

### 3. State Management

- Use useState for local state
- Use useContext for global state
- Use useReducer for complex state logic
- Avoid prop drilling with context
- Keep state as close to where it's used as possible

### 4. Performance Optimization

- Use React.memo for expensive components
- Implement useMemo and useCallback where appropriate
- Lazy load routes and components
- Optimize images and assets
- Use code splitting
- Implement virtual scrolling for lists > 100 items
- Use transform and opacity for animations (GPU-accelerated)
- Debounce expensive operations (search, validation)
- Implement pagination for large datasets
- Optimize Firestore queries with proper indexes

### 5. Error Handling

- Implement error boundaries
- Use try-catch blocks for async operations
- Provide meaningful error messages
- Log errors for debugging
- Handle network errors gracefully
- Show recovery actions (retry, contact support)
- Use appropriate error severity levels
- Implement offline error handling

### 6. Accessibility (WCAG 2.1 AA Compliance)

- Use semantic HTML elements (header, nav, main, aside, footer)
- Implement proper ARIA attributes (aria-label, aria-describedby, aria-live)
- Ensure keyboard navigation (Tab, Enter, Escape, Arrow keys)
- Maintain color contrast ratios (4.5:1 for text, 3:1 for UI components)
- Test with screen readers (VoiceOver, NVDA)
- Add skip links for keyboard users
- Implement focus traps in modals
- Use visible focus indicators (3px outline)
- Provide text alternatives for images
- Ensure form labels are properly associated

## 🎨 Styling Guidelines

### 1. TailwindCSS Usage

- Use utility classes for styling
- Create custom components for repeated patterns
- Use CSS custom properties for theming
- Implement responsive design with mobile-first approach
- Use consistent spacing and typography scales

### 2. Component Styling

```javascript
// ✅ Good: TailwindCSS with custom classes
const Button = ({ variant, size, children, ...props }) => {
  const baseClasses = "font-medium rounded-lg transition-colors focus:outline-none focus:ring-2";
  
  const variantClasses = {
    primary: "bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500",
    danger: "bg-red-600 text-white hover:bg-red-700 focus:ring-red-500"
  };
  
  const sizeClasses = {
    sm: "px-3 py-1.5 text-sm",
    md: "px-4 py-2 text-base",
    lg: "px-6 py-3 text-lg"
  };
  
  const classes = cn(baseClasses, variantClasses[variant], sizeClasses[size]);
  
  return (
    <button className={classes} {...props}>
      {children}
    </button>
  );
};
```

### 3. Responsive Design

- Use mobile-first approach
- Implement consistent breakpoints
- Test on multiple screen sizes
- Use flexible layouts
- Optimize for touch interactions

## 🧪 Testing Guidelines

### 1. Test Structure

- Write unit tests for components
- Write integration tests for services
- Write E2E tests for critical user flows
- Maintain 80%+ test coverage
- Use descriptive test names

### 2. Component Testing

```javascript
// ✅ Good: Component test structure
import { render, screen, fireEvent } from '@testing-library/react';
import TaskCard from '../TaskCard';

describe('TaskCard', () => {
  const mockTask = {
    id: '1',
    title: 'Test Task',
    description: 'Test Description',
    completed: false
  };

  it('should render task information', () => {
    render(<TaskCard task={mockTask} />);
    expect(screen.getByText('Test Task')).toBeInTheDocument();
  });

  it('should call onUpdate when task is edited', () => {
    const mockOnUpdate = jest.fn();
    render(<TaskCard task={mockTask} onUpdate={mockOnUpdate} />);
    
    fireEvent.click(screen.getByRole('button', { name: /edit/i }));
    // Test edit functionality
  });
});
```

## 🔒 Security Guidelines

### 1. Input Validation

- Validate all user inputs
- Sanitize data before storing
- Use proper data types
- Implement rate limiting
- Handle malicious input gracefully

### 2. Authentication & Authorization

- Use Firebase Auth for authentication
- Implement proper role-based access
- Validate user permissions
- Secure API endpoints
- Handle session management

### 3. Data Protection

- Encrypt sensitive data
- Use HTTPS for all communications
- Implement proper CORS policies
- Validate file uploads
- Handle user data privacy

## 📊 Performance Guidelines

### 1. Bundle Optimization

- Use code splitting
- Implement lazy loading
- Optimize images and assets
- Minimize bundle size
- Use CDN for static assets

### 2. Runtime Performance

- Optimize re-renders
- Use proper memoization
- Implement virtual scrolling
- Optimize animations
- Monitor performance metrics

### 3. Caching Strategy

- Implement service worker caching
- Use browser caching
- Cache API responses
- Implement offline functionality
- Optimize cache invalidation

## 🚀 Deployment Guidelines

### 1. Build Process

- Use Vite for building
- Implement proper environment variables
- Optimize for production
- Generate source maps
- Validate build output

### 2. Firebase Deployment

- Use Firebase Hosting
- Implement proper redirects
- Configure security headers
- Set up monitoring
- Implement rollback strategy

### 3. CI/CD Pipeline

- Use GitHub Actions
- Implement automated testing
- Run linting and formatting
- Deploy to staging first
- Implement proper versioning

## 📚 Documentation Guidelines

### 1. Code Documentation

- Use JSDoc for functions
- Document component props
- Explain complex logic
- Provide usage examples
- Keep documentation updated

### 2. README Files

- Provide setup instructions
- Document API endpoints
- Include contribution guidelines
- Provide troubleshooting tips
- Keep examples current

### 3. Architecture Documentation

- Document system architecture
- Explain design decisions
- Provide data flow diagrams
- Document security measures
- Keep technical specs updated

## 🔧 Development Workflow

### 1. Git Workflow

- Use feature branches
- Write descriptive commit messages
- Implement pull request reviews
- Use conventional commits
- Maintain clean git history

### 2. Code Review Process

- Review code thoroughly
- Check for security issues
- Verify performance impact
- Ensure accessibility compliance
- Test functionality manually

### 3. Release Process

- Use semantic versioning
- Generate changelog
- Test in staging environment
- Deploy during low-traffic hours
- Monitor post-deployment

## 🎯 Quality Standards

### 1. Code Quality

- Maintain clean, readable code
- Follow established patterns
- Implement proper error handling
- Use consistent formatting
- Write maintainable code

### 2. User Experience

- Ensure intuitive interface
- Implement proper loading states
- Provide meaningful feedback
- Handle errors gracefully
- Maintain consistent behavior

### 3. Performance

- Achieve fast load times
- Implement smooth animations
- Optimize for mobile devices
- Ensure responsive design
- Monitor performance metrics

## 🚨 Common Pitfalls to Avoid

### 1. React Anti-patterns

- Don't mutate state directly
- Avoid using index as key
- Don't forget to clean up effects
- Avoid unnecessary re-renders
- Don't ignore accessibility

### 2. Performance Issues

- Avoid large bundle sizes
- Don't overuse animations
- Avoid blocking operations
- Don't ignore mobile performance
- Avoid memory leaks

### 3. Security Vulnerabilities

- Don't trust user input
- Avoid exposing sensitive data
- Don't ignore authentication
- Avoid insecure dependencies
- Don't skip security updates

## 📖 Additional Resources

### 1. Documentation

- [React Documentation](https://react.dev/)
- [Vite Documentation](https://vitejs.dev/)
- [TailwindCSS Documentation](https://tailwindcss.com/docs)
- [Firebase Documentation](https://firebase.google.com/docs)
- [Framer Motion Documentation](https://www.framer.com/motion/)

### 2. Best Practices

- [React Best Practices](https://react.dev/learn)
- [Web Accessibility Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [Performance Best Practices](https://web.dev/performance/)
- [Security Best Practices](https://owasp.org/www-project-top-ten/)

### 3. Tools and Extensions

- React Developer Tools
- Redux DevTools
- Lighthouse
- WebPageTest
- axe DevTools

---

**Lưu ý**: Các quy tắc này được thiết kế để đảm bảo tính nhất quán, chất lượng và khả năng bảo trì của codebase. Tất cả team members cần tuân theo các quy tắc này khi phát triển tính năng mới.